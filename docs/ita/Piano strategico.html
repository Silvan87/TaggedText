<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<link rel="stylesheet" href="../_style/documentation.css">
	<title>Piano strategico</title>
</head>
<body>
<h1>Piano strategico</h1>
<h2>Piano di business</h2>
<h3>Prodotto</h3>
<p>Questo è un piano di business parziale e minimale che non nasce nel contesto di un'iniziativa d'impresa. Piuttosto, il progetto TaggedText nasce come strumento utile rivolto ai creatori di contenuti e come esempio didattico utile agli sviluppatori software. Non essendo un progetto commerciale, non si aspettano ricavi, ma altri benefici:</p>
<ul>
<li>Il principale beneficio è lo scopo dello strumento, ovvero avere una sintassi semplice, minimale, comoda ed espressiva per descrivere qualsiasi contenuto testuale così da focalizzarsi sul contenuto ed avere un codice sorgente di esso, senza pensare al layout e alla grafica. Più chiaramente:<ul>
<li>con <i>semplice</i> si intende semplice da leggere per un umano, possibilmente comprensibile "a colpo d'occhio";</li>
<li>con <i>minimale</i> si intende che va usato il numero minimo di caratteri speciali e convenzioni pur non limitando l'espressività;</li>
<li>con <i>comoda</i> si intende l'assenza di dipendenze da complessi strumenti come gli ambienti di sviluppo, il principale ausilio all'uso di questo linguaggio sarà la colorazione del testo da parte di semplici editor di testo, e si deve poter comunque scrivere come testo semplice;</li>
<li>con <i>espressiva</i> si può tenere come riferimento l'espressività del linguaggio <i>html</i>, quindi una struttura testuale gerarchica, ramificata, in cui ogni porzione di testo può essere qualificata affinché sia trattata nel modo desiderato.</li></ul>
</li>
<li>Avere un esempio didattico di un software di complessità non banale per mostrare come si sviluppa un software lungo il suo ciclo di vita:<ul>
<li>avere una panoramica dei principali metodi agili e vederne uno adottato nel progetto e in che modo esso traccia le attività lungo lo sviluppo;</li>
<li>presentare le possibili scelte per realizzare un'architettura software ed un codice puliti, ed avere un esempio della loro applicazione;</li>
<li>avere una guida ed un esempio su come si documenta un software, dall'ideazione alla sua distribuzione;</li>
<li>adottare l'approccio BDD (Behavior-Driver Development) fornendo una collezione di test costantemente aggiornata che prevenga le regressioni durante lo sviluppo arricchendo, al tempo stesso, la documentazione.</li></ul>
</li></ul>
<h3>Prodotti concorrenti</h3>
<p>Prima dell'ideazione della sintassi TaggedText, sono stati esaminati alcuni linguaggi esistenti che potessero offrire già il primo beneficio sopra elencato. Sono stati esaminati: html, LaTeX, markdown, reStructuredText, txt2tags, textile, json, yaml. Ma nessuno di questi è soddisfacente per le seguenti ragioni:</p>
<ul>
<li><b>html</b>: alcuni difetti salienti rispetto ai requisiti sono: <b>(1)</b> è scomodo aprire e chiudere tag &lt;&gt;&lt;/&gt; serve lasciare e premere shift alternativamente per digitare &lt;&gt; e servirsi di un ulteriore carattere di chiusura / che ne diminuisce la comodità d'uso nell'ottica di lavorarci come testo semplice in conflitto con il requisito di comodità; <b>(2)</b> il tag assegnato ad una porzione di testo va ripetuto in chiusura causando verbosità e ridondanza in conflitto con il requisito di minimalità; <b>(3)</b> un tag html può definire una porzione di testo ed il tag stesso può ricevere attributi con valori, però usando un numero più elevato di tag è possibile esprimere tutto quello che può esprimere l'html ma con una sintassi più semplice, ciò è in conflitto con il requisito di minimalità; <b>(4)</b> l'html per quanto riesca a separare la grafica dalla disposizione dei contenuti è abbastanza vincolato alla struttura e alla disposizione dei contenuti, richiede che si pensi in anticipo attraverso tabelle o divisori a soluzioni ammesse da <i>css</i> ma applicabili ad html solo se preparato in anticipo per quelle soluzioni, quindi non riesce effettivamente a disaccoppiarsi dalla disposizione del contenuto. L'elenco è più che sufficiente per ragionare su una diversa sintassi.</li>
<li><b>LaTeX</b>: questa sintassi non è solo per marcare il testo, ma offre la possibilità di inserire comandi per il documento da generare. Sicuramente l'espressività è ampia e ricca, ma <b>(1)</b> non è sufficientemente semplice e minimale. Si consideri che la sintassi che si vorrebbe realizzare potrebbe utilizzare come formati di destinazione pagine html o documenti in LaTeX che a loro volta possono produrre una pubblicazione stampabile o su altri supporti. Sono linguaggi che potrebbero lavorare in simbiosi, ma quello che si ricerca ora deve essere molto più semplice di LaTeX e molto più comodo da scrivere con ordinari editor di testo.</li>
<li><b>markdown</b>: principalmente permette la produzione di paragrafi html arricchiti con effetti ai caratteri, con link ed elementi testuali come paragrafi, elenchi puntati, titoli, tabelle e simili. Lo stile della sintassi è piuttosto naturale e intuitivo, il ché lo rende semplice e comodo, però <b>(1)</b> si serve di una serie di convenzioni specifiche che lo legano eccessivamente ad un sottoinsieme dei tag di html limitando molto la sua espressività; inoltre queste convenzioni specifiche <b>(2)</b> non rendono la sintassi abbastanza minimale ma la articolano eccessivamente per marcare ogni lieve differenza di stile e di elemento. Per quanto risulti preferibile ad html, non può soddisfare 2 importanti requisiti e quindi va scartato.</li>
<li><b>reStructuredText</b>, <b>txt2tags</b>, <b>textile</b>: quanto detto per markdown, si applica anche a reStructuredText, txt2tags e textile, essi usano altri espedienti sintattici che potrebbero piacere di più o di meno come stile, ma restano eccessivamente legati ad una semplificazione di alcuni tag ricorrenti in html, che li rendono suscettibili alle due critiche precedenti <b>(1) (2)</b>.</li>
<li><b>json</b>: la sintassi di json è semplice, apprezzabilmente minimale, ampiamente espressiva e flessibile. L'unico serio difetto è che <b>(1)</b> non è comodo da scrivere. Verosimilmente avremo elenchi di elementi da inserire nelle parentesi quadre [] e questi elementi raramente saranno solo pezzi di stringa, ma saranno oggetti da descrivere quindi con parantesi graffe {} ed ogni attributo andrà specificato usando le virgolette "", richieste anche dal valore dell'attributo. È facile comprendere che nell'ottica di descrivere un intero libro o un sito vetrina o una collezione di script questi grandi oggetti json diventeranno presto di difficilissima lettura ed arduamenti modificabile senza causare incoerenze nella struttura delle parentesi. Leggibilità e comodità non sono soddisfatte da json e vale la pena ideare una differente sintassi.</li>
<li><b>yaml</b>: oltre ad essere semplice, minimale, espressivo e flessibile come json ed anche meglio, risulta anche piuttosto comodo da scrivere. Un sottoinsieme della grammatica di yaml risulterebbe sufficientemente minimale e adatto allo scopo. Un limite tra i più impattanti per gli scopi prefissi è che <b>(1)</b> le mappe yaml, composte di chiave e valore, non permettono all'interno del valore di definire porzioni di testo con tag particolari, come per esempio permette di fare html, bisognerebbe spezzare il testo in modo innaturale e mapparlo, per esempio, in pezzi normali e in pezzi che vanno rappresentati in grassetto o con altri effetti. Un requisito dell'espressività era che qualsiasi sottostringa potesse ricevere un attributo, conservando una soluzione minimale e comoda, purtroppo yaml non è soddisfacente a tal riguardo. <b>(2)</b> Una seconda ragione meno impattante ma menzionabile è che yaml è ben interpretabile se si conoscono le strutture dati <i>lista</i> e <i>mappa</i>, ma va considerata una sintassi che esprima il concetto di testo con un tag (o attributo) attraverso il solo concetto di mappa. Se c'è un unico elemento possibile nella sintassi non serve controllare nulla per capire se ci si trova dentro una lista o dentro una mappa. Ed ancora, <b>(3)</b> yaml si serve di svariati caratteri speciali per conservare la preformattazione o un certo tipo di concatenamento tra stringhe interrotte da un ritorno a capo, anche in questo caso potrebbe essere utile trovare soluzioni più semplici. Risulta sicuramente un buon candidato, ma è preferibile ricercare una sintassi più rispondente agli scopi prefissi.</li></ul>
<h3>Visione</h3>
<p>Immagino una sintassi molto semplice che permetta di partire subito, con un semplice editor di testo, scrivendo un post o un articolo o il capitolo di un libro o le informazioni di un report o i contenuti per un sito web vetrina o qualsiasi pubblicazione testuale e, attraverso dei modelli scritti con la medesima semplice sintassi, modelli di cui ci si può occupare in un secondo momento o preparati da altri o dall'autore stesso in passato, ottenere le pubblicazioni graficamente ben curate, con creazione automatica degli indici, con numerazione automatica di note o altro, e nel formato testuale desiderato (markdown, html, epub, ecc.).</p>
<p>L'idea di fondo è avere un linguaggio simile ad HTML, ma molto più comodo da scrivere e da leggere e con la stessa espressività, che possa svolgere il ruolo di codice sorgente per qualsiasi contenuto testuale. Questo permetterebbe di gestire e aggiornare i propri contenuti testuali in un unico formato (TaggedText) e, quando necessiteremo di aggiornare o ampliare tali contenuti, la modifica potrà essere riflessa su molteplici file di destinazione, senza doverli aggiornare uno per uno.</p>
<p>In futuro, si potrebbe far uso di tag speciali nelle regole dei modelli per generare non solo testo, ma anche dati binari, come byte, interi a 16 o 32 bit, con o senza segno, ecc. Questo permetterebbe di descrivere e generare in modo semplice un file binario, potrebbe risultare utile in contesti di nicchia in cui si vuole personalizzare in modo comodo un file di sistema o di un programma o di un gioco che non sempre sono puramente testuali.</p>
<h3>Missione</h3>
<p>Essendo il progetto di un singolo individuo e non di un'organizzazione, non c'è una particolare missione dietro queste iniziative. In linea di massima, ho piacere che esista un riferimento ad un software realizzato allo stato dell'arte, che funga al tempo stesso da guida e traccia per progetti che vorranno soddisfare analoghi livelli di qualità e completezza.</p>
<h2>Piano di progetto</h2>
<p>Nel progetto lavorerà una sola risorsa, l'autore di TaggeText, che sarà sia committente che sviluppatore <i>full stack</i>. È poco probabile che altre risorse si uniranno al progetto, almeno finché non raggiungerà una maturità interessante. Le tempistiche non possono essere stimate, è un progetto che avanzerà lentamente nei ritagli di tempo libero. Nonostante ciò, si mira a raggiungere un'elevata qualità del software, con una documentazione completa, principi di <i>clean code</i>, tracciamento delle attività, test di non regressione, manuale per l'utente. Lo strumento sarà usato localmente, il sistema ospitante sarà l'unico ambiente disponibile. In base al ruolo, avremo un ambiente di produzione per l'utente finale, e di sviluppo e testing per gli sviluppatori.</p>

</body>
</html>